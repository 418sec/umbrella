import { repeatedly } from "@thi.ng/transducers/iter/repeatedly";

import { Triple, Pattern } from "./api";
import { isQVar, autoQVar, qvarName } from "./qvar";

export const patternVarCount = (p: Pattern) => {
    let n = 0;
    if (isQVar(p[0])) n++;
    if (isQVar(p[1])) n++;
    if (isQVar(p[2])) n++;
    return n;
};

/**
 * Takes a path triple pattern and max depth. The pattern's predicate
 * must be a seq of preds. Returns a 2-elem vector [patterns vars],
 * where `patterns` is a seq of query patterns with injected temp qvars
 * for in between patterns and`vars` the autogenerated qvars themselves.
 *
 * Example:
 *
 * ```
 * ["?s", [p1, p2, p3], "?o"] =>
 * [
 *   [["?s", p1, "?__q0"], ["?__q0", p2, "?__q1"], ["?__q1", p3, "?o"] ],
 *   ["?__q0", "?__q1"]
 * ]
 * ```
 *
 * @param pattern
 * @param maxd
 */
export const resolvePathPattern = ([s, p, o], maxd = p.length) => {
    const res = [];
    const avars = [...repeatedly(autoQVar, maxd - 1)];
    for (let i = 0; i < maxd; i++) {
        res.push([s, p[i % p.length], s = avars[i]]);
    }
    res[res.length - 1][2] = o;
    return [res, avars];
};

export const sortPatterns = (patterns: Pattern[]) =>
    patterns.sort((a, b) => patternVarCount(a) - patternVarCount(b));

/**
 * Returns an optimized query variable solution extractor function based
 * on given pattern type. `vs`, `vp`, `vo` are flags to indicate if `s`,
 * `p` and/or `o` pattern items are query variables. The returned fn
 * will be optimized to 1 of the 8 possible case and accepts a single
 * fact to extract the respective variables from.
 *
 * @param vs
 * @param vp
 * @param vo
 * @param s
 * @param p
 * @param o
 */
export const qvarResolver = (vs: boolean, vp: boolean, vo: boolean, s, p, o) => {
    const type = ((<any>vs) << 2) | ((<any>vp) << 1) | (<any>vo);
    let ss: any = vs && qvarName(s);
    let pp: any = vp && qvarName(p);
    let oo: any = vo && qvarName(o);
    switch (type) {
        case 0:
        default:
            return;
        case 1:
            return (f: Triple) => ({ [oo]: f[2] });
        case 2:
            return (f: Triple) => ({ [pp]: f[1] });
        case 3:
            return (f: Triple) => ({ [pp]: f[1], [oo]: f[2] });
        case 4:
            return (f: Triple) => ({ [ss]: f[0] });
        case 5:
            return (f: Triple) => ({ [ss]: f[0], [oo]: f[2] });
        case 6:
            return (f: Triple) => ({ [ss]: f[0], [pp]: f[1] });
        case 7:
            return (f: Triple) => ({ [ss]: f[0], [pp]: f[1], [oo]: f[2] });
    }
};
