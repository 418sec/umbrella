import { Keys } from "@thi.ng/api";
import { Subscription, subscription } from "../subscription";
import { CommonOpts } from "../api";
import { optsWithID } from "../utils/idgen";

/**
 * Result object type for {@link fromObject}.
 */
export interface StreamObj<T, K extends Keys<T>> {
    /**
     * Object of managed streams for registered keys.
     */
    streams: {
        [id in K]-?: Subscription<T[id], T[id]>;
    };
    /**
     * Feeds new values from `x` to each registered key's stream.
     * Satifies {@link ISubscriber.next} interface.
     *
     * @param x
     */
    next(x: T): void;
    /**
     * Calls {@link ISubscriber.done} for all streams created. Satifies
     * {@link ISubscriber.done} interface.
     */
    done(): void;
}

export interface StreamObjOpts extends CommonOpts {
    /**
     * If true (default), all created streams will be seeded with key
     * values from the source object.
     *
     * @defaultValue true
     */
    initial: boolean;
}

/**
 * Takes an arbitrary object `src` and optional array of `keys` (else
 * selects all by default). Creates a new object and for each key
 * creates a new stream, optionally seeded with the key's value in
 * `src`. Returns new object of streams.
 *
 * @remarks
 * The structure of the returned object is
 * {@link StreamObj | as follows}:
 *
 * ```ts
 * {
 *   streams: { ... },
 *   next(x): void;
 *   done(): void;
 * }
 * ```
 *
 * All streams (only for given `keys`) will be stored under `streams`.
 * The `next()` and `done()` functions/methods allow the object itself
 * to be used as subscriber for an upstream subscribable (see 2nd
 * example):
 *
 * - `next()` - takes a object of same type as `src` and feeds each
 *   key's new value into its respective stream.
 * - `done()` - calls {@link ISubscriber.done} on all streams
 *
 * The optional `opts` arg is used to specify shared options for *all*
 * created streams. If the `id` option isn't provided, each stream will
 * get an autogenerated ID in the form `obj-${keyname}-${counter}`.
 *
 * @example
 * ```ts
 * type Foo = { a?: number; b: string; };
 *
 * const obj = fromObject(<Foo>{ a: 1, b: "foo" })
 *
 * obj.streams.a.subscribe(trace("a"))
 * // a 1
 * obj.streams.b.subscribe(trace("b"))
 * // b foo
 *
 * obj.next({ b: "bar" })
 * // a undefined
 * // b bar
 * ```
 *
 * @example
 * ```ts
 * const obj = fromObject(<Foo>{}, ["a", "b"], { initial: false });
 * obj.streams.a.subscribe(trace("a"));
 * obj.streams.b.subscribe(trace("b"));
 *
 * const src = subscription<Foo, Foo>();
 * // use as subscriber
 * src.subscribe(obj);
 *
 * src.next({ a: 1, b: "foo" });
 * // a 1
 * // b foo
 * ```
 *
 * @param src
 * @param keys
 * @param opts
 */
export const fromObject = <T, K extends Keys<T>>(
    src: T,
    keys: K[] = <any>Object.keys(src),
    opts: Partial<StreamObjOpts> = {}
) => {
    const streams: any = {};
    const res = <StreamObj<T, K>>{
        streams,
        next(state) {
            for (let k of keys) {
                streams[k].next(<any>state[k]);
            }
        },
        done() {
            for (let k of keys) {
                streams[k].done();
            }
        },
    };
    for (let k of keys) {
        streams[k] = <any>subscription(undefined, optsWithID(`obj-${k}`, opts));
        opts.initial !== false && streams[k].next(<any>src[k]);
    }
    return res;
};
