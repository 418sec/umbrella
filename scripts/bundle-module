#!/usr/bin/env node
const fs = require("fs");
const rollup = require("rollup");
const terser = require("terser");
const gz = require("gzip-size");

const camelCase =
    (x) => x.replace(/\-+(\w)/g, (_, c) => c.toUpperCase());

const size =
    (x) => (x / 1024).toFixed(2) + "KB";

const name = process.argv[2];

const deps = process.argv
    .slice(3)
    .reduce(
        (acc, x) => (acc[`@thi.ng/${x}`] = `thi.ng.${camelCase(x)}`, acc),
        {}
    );

const inOpts = {
    external: Object.keys(deps),
    input: "./index.js"
};

const terserOpts = {
    compress: true,
    mangle: true,
    ecma: 6
};

const buildVersion =
    async (dest, outOpts, write = true, compressed = false) => {
        console.log(`bundling (${outOpts.format}): ${dest}`);
        const bundle = await rollup.rollup(inOpts);
        const bundleOut = (await bundle.generate(outOpts)).output[0].code;
        const terserOut = terser.minify(bundleOut, terserOpts).code;
        write && fs.writeFileSync(dest, compressed ? terserOut : bundleOut);

        const gzSize = gz.sync(terserOut);
        console.log(`\tsize: ${size(terserOut.length)} / gzipped: ${size(gzSize)}`);
        return { raw: terserOut.length, gzip: gzSize };
    };

const build =
    async () => {

        !fs.existsSync("lib") && fs.mkdirSync("lib");
        !fs.existsSync(".meta") && fs.mkdirSync(".meta");

        const cjs = await buildVersion(
            "lib/index.js",
            {
                format: "cjs"
            }
        );

        const esm = await buildVersion(
            "lib/index.es6.js",
            {
                format: "esm"
            },
            false
        );

        const umd = await buildVersion(
            "lib/index.umd.js",
            {
                format: "umd",
                globals: deps,
                name: `thi.ng.${name}`,
            },
            true,
            true
        );

        fs.writeFileSync(".meta/size.json", JSON.stringify({ esm, cjs, umd }));
    };

build();
